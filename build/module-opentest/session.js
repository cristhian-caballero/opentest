const axios = require('axios').default;
const fs = require('fs');
const helpers = require('./helpers');
const path = require('path');
const urlJoin = require('url-join');

/** Time interval between two successive API calls to check the status of a
 * pending test session, in milliseconds. Default: 5000. */
let sessionCompleteCheckInterval = 5 * 1000;

/** Maximum time interval the CLI will wait for a broken network connection to
 * the server to be restored, in milliseconds. Default: 15 minutes. */
let serverDownMaxTimeout = 15 * 60 * 1000;

let lastServerResponseTimestamp = Date.now();

module.exports = {
	createSessionFromTemplate: createSessionFromTemplate,
	createSessionFromTemplateAndWait: createSessionFromTemplateAndWait
}

/**
 * Count the total number of tests that have the
 * specified result.
 */
function countTestsWithResult(tests, result) {
	var total = 0;

	tests.forEach(function (test) {
		if (!test.isDataDriven) {
			if (test.result == result) {
				total++;
			}
		} else {
			test.subtests.forEach(function (test) {
				if (test.result == result) {
					total++;
				}
			});
		}
	});

	return total;
}

/**
 * Create a new test session from a template file and return a promise
 * that resolves to the session ID. */
function createSessionFromTemplate(templatePartialPath, options) {
	options = options || {};
	const syncServerUrl = options.server || 'http://localhost:3000';

	const reqOptions = {
		url: urlJoin(syncServerUrl, 'api/session'),
		method: 'POST',
		data: {
			template: {
				name: path.basename(templatePartialPath, path.extname(templatePartialPath)),
				path: path.dirname(templatePartialPath)
			}
		}
	};
	if (options.environment) {
		reqOptions.data.environment = options.environment;
	}
	if (options.actorTags) {
		reqOptions.data.actorTags = options.actorTags;
	}

	return new Promise(function (resolve, reject) {
		axios(reqOptions)
			.then(function (res) {
				const sessionId = res.data.sessionId;
				console.log("Started test session " + sessionId);
				resolve(sessionId);
			})
			.catch(function (err) {
				console.log('Error: ', err.message);
				if (err.response && err.response.data) {
					console.log('Response payload: ', err.response.data);
				}
				reject(err);
			});
	});
}

/**
 * Create a new test session from a template file and waits for the test
 * session to complete before returning. Options: timeout, server, outFile,
 * environment.*/
function createSessionFromTemplateAndWait(templatePartialPath, options) {
	options = options || {};
	const timeout = options.timeout || 7200;
	const syncServerUrl = options.server || 'http://localhost:3000';
	let outFile = null;
	if (typeof options.outFile === 'string' || options.outFile instanceof String) {
		outFile = helpers.trimChars(options.outFile);
	}
	const createOptions = { server: syncServerUrl };
	if (options.environment) {
		createOptions.environment = options.environment;
	}
	if (options.actorTags) {
		createOptions.actorTags = options.actorTags;
	}

	createSessionFromTemplate(templatePartialPath, createOptions)
		.then(function (sessionId) {
			let startTime = Date.now();

			console.log(`Session completion timeout is set to ${timeout} seconds`);
			console.log(`Waiting for the test session to complete...`);

			// Check the test session status periodically, until the test
			// session is complete or the configured timeout expires
			setTimeout(checkSessionCompleted, sessionCompleteCheckInterval);

			function checkSessionCompleted() {
				exitIfSessionCompleted(sessionId, startTime, timeout, syncServerUrl, outFile);
				setTimeout(checkSessionCompleted, sessionCompleteCheckInterval);
			}
		})
		.catch(function (err) {
			console.log('ERROR: ', err);
			process.exit(1);
		});
}

function exitIfSessionCompleted(sessionId, startTime, timeoutSec, syncServerUrl, outFile) {
	if (Date.now() - startTime > timeoutSec * 1000) {
		console.log(`Timeout of ${timeoutSec} seconds exceeded while waiting for test session to complete`);
		process.exit(1);
	}

	syncServerUrl = syncServerUrl || 'http://localhost:3000';

	getTestSessionInfo(sessionId, syncServerUrl)
		.then(function (sessionInfo) {
			sessionCompleteCheckInterval = 5000;
			lastServerResponseTimestamp = Date.now();

			if (sessionInfo.status == 'completed') {
				if (sessionInfo.result == 'passed') {
					var passed = countTestsWithResult(sessionInfo.tests, "passed");

					console.log(`${passed} test(s) passed`);
					console.log(`Test session ${sessionId} completed successfully`);

					outputSessionInfo(sessionId, syncServerUrl, outFile)
						.then(() => {
							process.exit(0);
						});
				} else {
					console.log(`${sessionInfo.testCounts.passed} test(s) passed`);
					console.log(`${sessionInfo.testCounts.failed} test(s) failed`);
					console.log(`Test session ${sessionId} failed`);

					console.log(
						'\nThe failed tests were:\n' +
						sessionInfo.tests
							.filter((t) => { return t.result != 'passed'; })
							.map((t) => {
								return '  - ' + helpers.trimChars(t.path.trim() + '/' + t.name.trim(), '/');
							})
							.join('\n'));
					const sessionInfoUrl = urlJoin(syncServerUrl, 'session/' + sessionId);
					console.log(`\nFor additional details go to ${sessionInfoUrl}`);
					outputSessionInfo(sessionId, syncServerUrl, outFile)
						.then(() => {
							process.exit(1);
						});
				}
			}
		})
		.catch(function (err) {
			if (Date.now() - lastServerResponseTimestamp > serverDownMaxTimeout) {
				console.log('ERROR: ', err, '\n');
				console.log(`Timeout of ${Math.round(serverDownMaxTimeout/1000)} seconds exceeded while waiting for server to respond`);
				process.exit(1);
			} else {
				const lastResponseInterval = Math.round((Date.now() - lastServerResponseTimestamp)/1000);
				console.log(`ERROR: Could not receive a response from the server in ${lastResponseInterval} seconds`);
			}

			if (sessionCompleteCheckInterval < 20000) {
				sessionCompleteCheckInterval += 5000;
			}
		});
}

/** Writes the session information to disk, as a JUnit XML test results
 * file, or in the specified format. */
function outputSessionInfo(sessionId, syncServerUrl, outFile, outFormat) {
	if (!outFile) {
		return Promise.resolve();
	}

	outFormat = outFormat || 'junit';
	syncServerUrl = syncServerUrl || 'http://localhost:3000';

	const reqOptions = {
		url: urlJoin(syncServerUrl, `api/session/${sessionId}`),
		method: 'get',
		params: { format: outFormat }
	};

	return new Promise(function (resolve, reject) {
		let data = null;

		axios(reqOptions)
			.then(function (res) {
				fs.writeFileSync(outFile, res.data);
				data = res.data;
			})
			.catch(function (err) {
				console.log('Failed to write the JUnit XML to disk.', err.message);
			})
			.finally(function (err) {
				resolve(data);
			});
	});
}

function getTestSessionInfo(sessionId, syncServerUrl) {
	syncServerUrl = syncServerUrl || 'http://localhost:3000';

	const reqOptions = {
		url: urlJoin(syncServerUrl, `api/session/${sessionId}`),
		method: 'get'
	};

	return new Promise(function (resolve, reject) {
		axios(reqOptions)
			.then(function (res) {
				resolve(res.data);
			})
			.catch(function (err) {
				reject(err);
			});
	});
}